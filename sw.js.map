{"version":3,"sources":["webpack:///sw.js","webpack:///webpack/bootstrap 4aff718b786f31e14ddc","webpack:///./books-redux/sw.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","console","log","serviceWorkerOption","urlsToCache","assets","self","addEventListener","event","waitUntil","caches","open","then","cache","addAll","data","ports","postMessage","respondWith","match","request","response","fetchRequest","clone","fetch","status","responseToCache","put"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAI,EAAAJ,EACAK,GAAA,EACAH,WAUA,OANAJ,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,GAAA,EAGAF,EAAAD,QAvBA,GAAAD,KA4BAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAK,EAAA,SAAAK,GAA2C,MAAAA,IAG3CV,EAAAW,EAAA,SAAAR,EAAAS,EAAAC,GACAb,EAAAc,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAb,EAAAoB,EAAA,SAAAhB,GACA,GAAAS,GAAAT,KAAAiB,WACA,WAA2B,MAAAjB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAJ,GAAAW,EAAAE,EAAA,IAAAA,GACAA,GAIAb,EAAAc,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAlB,KAAAe,EAAAC,IAGtDvB,EAAA0B,EAAA,IAGA1B,IAAA2B,EAAA,KDMM,SAAUvB,EAAQD,GEtExByB,QAAQC,IAAI,uBAAwBC,oBAEpC,IAEIC,GAAcD,oBAAoBE,MAEtCC,MAAKC,iBAAiB,UAAW,SAAAC,GAG/BA,EAAMC,UACJC,OAAOC,KARM,yBASVC,KAAK,SAACC,GAEL,MADAZ,SAAQC,IAAI,gBACLW,EAAMC,OAAOV,QAK5BE,KAAKC,iBAAiB,WAAY,SAAAC,GAChCP,QAAQC,IAAI,oCAGdI,KAAKC,iBAAiB,UAAW,SAAAC,GAC/BP,QAAQC,IAAI,wBAA0BM,EAAMO,MAC5CP,EAAMQ,MAAM,GAAGC,YAAY,2BAK7BX,KAAKC,iBAAiB,QAAS,SAACC,GAC9BA,EAAMU,YACJR,OAAOS,MAAMX,EAAMY,SAChBR,KAAK,SAACS,GAEL,GAAIA,EACF,MAAOA,EAOT,IAAIC,GAAed,EAAMY,QAAQG,OAEjC,OAAOC,OAAMF,GAAcV,KACzB,SAACS,GAEC,IAAKA,GAAgC,MAApBA,EAASI,OACxB,MAAOJ,EAOT,IAAIK,GAAkBL,EAASE,OAO/B,OALAb,QAAOC,KAvDF,yBAwDFC,KAAK,SAACC,GACLA,EAAMc,IAAInB,EAAMY,QAASM,KAGtBL","file":"sw.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nconsole.log(\"serviceWorkerOption:\", serviceWorkerOption);\n\nvar CACHE_NAME = 'react-redux-poc_CACHE';\n\nvar urlsToCache = serviceWorkerOption.assets;\n\nself.addEventListener('install', function (event) {\n  // Perform install steps\n  // Perform install steps\n  event.waitUntil(caches.open(CACHE_NAME).then(function (cache) {\n    console.log('Opened cache');\n    return cache.addAll(urlsToCache);\n  }));\n});\n\nself.addEventListener('activate', function (event) {\n  console.log(\"new worker activated: Ho Hooo!\");\n});\n\nself.addEventListener('message', function (event) {\n  console.log(\"SW Received Message: \" + event.data);\n  event.ports[0].postMessage(\"SW Says 'Hello back!'\");\n  // Then once the event is triggered, if the message triggerer is havnig a callback,\n  // resolve the promice\n});\n\nself.addEventListener('fetch', function (event) {\n  event.respondWith(caches.match(event.request).then(function (response) {\n    // Cache hit - return response\n    if (response) {\n      return response;\n    }\n\n    // IMPORTANT: Clone the request. A request is a stream and\n    // can only be consumed once. Since we are consuming this\n    // once by cache and once by the browser for fetch, we need\n    // to clone the response.\n    var fetchRequest = event.request.clone();\n\n    return fetch(fetchRequest).then(function (response) {\n      // Check if we received a valid response\n      if (!response || response.status !== 200) {\n        return response;\n      }\n\n      // IMPORTANT: Clone the response. A response is a stream\n      // and because we want the browser to consume the response\n      // as well as the cache consuming the response, we need\n      // to clone it so we have two streams.\n      var responseToCache = response.clone();\n\n      caches.open(CACHE_NAME).then(function (cache) {\n        cache.put(event.request, responseToCache);\n      });\n\n      return response;\n    });\n  }));\n});\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// sw.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4aff718b786f31e14ddc","console.log(\"serviceWorkerOption:\", serviceWorkerOption);\r\n\r\nlet CACHE_NAME = 'react-redux-poc_CACHE';\r\n\r\nlet urlsToCache = serviceWorkerOption.assets;\r\n\r\nself.addEventListener('install', event => {\r\n  // Perform install steps\r\n   // Perform install steps\r\n  event.waitUntil(\r\n    caches.open(CACHE_NAME)\r\n      .then((cache) => {\r\n        console.log('Opened cache');\r\n        return cache.addAll(urlsToCache);\r\n      })\r\n  );\r\n});\r\n\r\nself.addEventListener('activate', event => {\r\n  console.log(\"new worker activated: Ho Hooo!\");\r\n})\r\n\r\nself.addEventListener('message', event => {\r\n  console.log(\"SW Received Message: \" + event.data);\r\n  event.ports[0].postMessage(\"SW Says 'Hello back!'\");\r\n  // Then once the event is triggered, if the message triggerer is havnig a callback,\r\n  // resolve the promice\r\n})\r\n\r\nself.addEventListener('fetch', (event) => {\r\n  event.respondWith(\r\n    caches.match(event.request)\r\n      .then((response) => {\r\n        // Cache hit - return response\r\n        if (response) {\r\n          return response;\r\n        }\r\n\r\n        // IMPORTANT: Clone the request. A request is a stream and\r\n        // can only be consumed once. Since we are consuming this\r\n        // once by cache and once by the browser for fetch, we need\r\n        // to clone the response.\r\n        var fetchRequest = event.request.clone();\r\n\r\n        return fetch(fetchRequest).then(\r\n          (response) => {\r\n            // Check if we received a valid response\r\n            if (!response || response.status !== 200) {\r\n              return response;\r\n            }\r\n\r\n            // IMPORTANT: Clone the response. A response is a stream\r\n            // and because we want the browser to consume the response\r\n            // as well as the cache consuming the response, we need\r\n            // to clone it so we have two streams.\r\n            var responseToCache = response.clone();\r\n\r\n            caches.open(CACHE_NAME)\r\n              .then((cache) => {\r\n                cache.put(event.request, responseToCache);\r\n              });\r\n\r\n            return response;\r\n          }\r\n        );\r\n      })\r\n    );\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./books-redux/sw.js"],"sourceRoot":""}